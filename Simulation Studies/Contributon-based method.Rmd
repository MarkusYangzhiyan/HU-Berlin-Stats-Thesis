---
title: "Contributon-based method"
author: "Zhiyan Yang"
date: "2025-12-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# B=12 simulatio: H0 distribution and cutoffs

```{r}

if (!require("pacman")) install.packages("pacman")
pacman::p_load(lme4, RLRsim, ggplot2, dplyr, tidyr, patchwork, foreach, doParallel)


B <- 12
n_ind_fix <- 100

try(stopCluster(cl), silent = TRUE) 
num_cores <- parallel::detectCores() - 2
cl <- makeCluster(num_cores)
registerDoParallel(cl)


# --- 1.1 func of data generation ---
Generate_Data_MC <- function(n_ind) {
  time_points <- c(0, 6, 12)
  n_time <- length(time_points)
  n_obs <- n_ind * n_time
  n_nutri <- 6
  np <- c(100, 100, 100, 100, 100, 100, 400)
  
  Nutri <- matrix(rnorm(n_obs * n_nutri), nrow = n_obs, ncol = n_nutri)
  colnames(Nutri) <- paste0("Nutri", 1:n_nutri)
  time_all <- rep(time_points, times = n_ind)
  
  D <- matrix(0, nrow = n_obs, ncol = sum(np))
  t_idx <- match(time_all, unique(time_points))
  ind_id <- rep(1:n_ind, each = n_time)
  
  curr <- 0
  # M1: Inter
  for(i in 1:np[1]) {
    curr <- curr + 1
    eff <- rowSums(Nutri * matrix(rnorm(n_time*n_nutri)[t_idx + (0:(n_nutri-1))*n_time], n_obs, n_nutri)) + 
           as.numeric(Nutri %*% rnorm(n_nutri)) + rnorm(n_time)[t_idx] + rnorm(n_ind)[ind_id]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M2: Nutri + Time + RI
  for(i in 1:np[2]) {
    curr <- curr + 1
    eff <- as.numeric(Nutri %*% rnorm(n_nutri)) + rnorm(n_time)[t_idx] + rnorm(n_ind)[ind_id]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M3: Nutri + RI
  for(i in 1:np[3]) {
    curr <- curr + 1
    eff <- as.numeric(Nutri %*% rnorm(n_nutri)) + rnorm(n_ind)[ind_id]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M4: Time + RI
  for(i in 1:np[4]) {
    curr <- curr + 1
    eff <- rnorm(n_time)[t_idx] + rnorm(n_ind)[ind_id]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M5: Nutri + Time (No RI)
  for(i in 1:np[5]) {
    curr <- curr + 1
    eff <- as.numeric(Nutri %*% rnorm(n_nutri)) + rnorm(n_time)[t_idx]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M6: RI Only
  for(i in 1:np[6]) {
    curr <- curr + 1
    eff <- rnorm(n_ind)[ind_id]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M7: Noise
  for(i in 1:np[7]) {
    curr <- curr + 1
    D[, curr] <- rnorm(n_obs)
  }
  
  true_cls <- rep(paste0("M", 1:7), times = np)
  return(list(D = D, Nutri = Nutri, time = time_all, true_cls = true_cls))
}

# --- 1.2 helper func ---
safe_lmer <- function(form, data, REML) {
  tryCatch(lmer(form, data = data, REML = REML, 
                control = lmerControl(check.conv.singular = "ignore", calc.derivs = FALSE)),
           error = function(e) NULL, warning = function(w) invokeRestart("muffleWarning"))
}

# P-values
fit_get_pvals <- function(yvec, base_df, nutri_terms) {
  df <- base_df; df$y <- as.numeric(yvec)
  f_add <- as.formula(paste0("y ~ time + ", nutri_terms, " + (1|id)"))
  f_full <- as.formula(paste0("y ~ time * (", nutri_terms, ") + (1|id)"))
  f_noN <- as.formula("y ~ time + (1|id)")
  f_noT <- as.formula(paste0("y ~ ", nutri_terms, " + (1|id)"))
  
  m_add <- safe_lmer(f_add, df, FALSE)
  m_full <- safe_lmer(f_full, df, FALSE)
  m_noN <- safe_lmer(f_noN, df, FALSE)
  m_noT <- safe_lmer(f_noT, df, FALSE)
  
  p_inter <- if(!is.null(m_add) && !is.null(m_full)) anova(m_add, m_full)$`Pr(>Chisq)`[2] else 1
  p_N <- if(!is.null(m_noN) && !is.null(m_add)) anova(m_noN, m_add)$`Pr(>Chisq)`[2] else 1
  p_T <- if(!is.null(m_noT) && !is.null(m_add)) anova(m_noT, m_add)$`Pr(>Chisq)`[2] else 1
  
  m_reml <- safe_lmer(update(f_add, .~.), df, TRUE)
  rlrt <- if(!is.null(m_reml)) tryCatch(RLRsim::exactRLRT(m_reml), error=function(e) NULL) else NULL
  p_RI <- if(!is.null(rlrt)) rlrt$p.value[1] else 1
  if(is.na(p_RI)) p_RI <- 1 
  
  return(c(p_inter, p_N, p_T, p_RI))
}

# effect_shares
calculate_effect_shares <- function(y, id, time, Nutri_mat) {
  time <- factor(time); id <- factor(id)
  N <- scale(Nutri_mat, center = TRUE, scale = FALSE)
  df <- data.frame(y=y, id=id, time=time); df <- cbind(df, as.data.frame(N))
  
  nutri_cols <- colnames(N)
  inter_term <- paste0("(", paste(nutri_cols, collapse="+"), ")")
  form <- as.formula(paste0("y ~ ", inter_term, "*time + (1|id)"))
  
  fit <- safe_lmer(form, df, TRUE)
  if(is.null(fit)) return(rep(NA, 5))
  
  X <- model.matrix(fit); b <- fixef(fit); cn <- colnames(X)
  idx_nut <- grepl(paste0("^(", paste(nutri_cols, collapse="|"), ")$"), cn)
  idx_time <- grepl("^time", cn) & !grepl(":", cn)
  idx_int <- grepl(":", cn)
  
  calc_SS <- function(idx) {
    if(sum(idx)==0) return(0)
    eff <- as.numeric(X[, idx, drop=FALSE] %*% b[idx])
    sum((eff - mean(eff))^2)
  }
  SS_nut <- calc_SS(idx_nut)
  SS_time <- calc_SS(idx_time)
  SS_int <- calc_SS(idx_int)
  
  ran <- ranef(fit)$id[,1]
  SS_id <- sum(ran[df$id]^2)
  SS_eps <- sum(residuals(fit)^2)
  
  Ttot <- SS_nut + SS_time + SS_int + SS_id + SS_eps
  if(Ttot < 1e-9) return(rep(0, 5))
  
  res <- c(SS_int, SS_nut, SS_time, SS_id, SS_eps) / Ttot
  res[res < 0] <- 0
  if(sum(res) == 0) return(rep(0, 5))
  return(res / sum(res))
}

# --- 1.3 ANOVA classification rules---
classify_by_anova <- function(p_mat, alpha = 0.05) {
  n <- nrow(p_mat)
  pred <- rep(NA, n)
  sig <- function(p) !is.na(p) & p < alpha
  
  for(i in 1:n) {
    p_I <- p_mat[i, 1]; p_N <- p_mat[i, 2]; p_T <- p_mat[i, 3]; p_RI <- p_mat[i, 4]
    
    if (!sig(p_I) && !sig(p_N) && !sig(p_T) && !sig(p_RI)) {
      pred[i] <- "M7"
    } else {
      if (sig(p_I)) {
        pred[i] <- "M1"
      } else {
        if (!sig(p_RI)) {
          pred[i] <- "M5"
        } else {
          if (sig(p_N) && sig(p_T)) {
            pred[i] <- "M2"
          } else if (sig(p_N) && !sig(p_T)) {
            pred[i] <- "M3"
          } else if (!sig(p_N) && sig(p_T)) {
            pred[i] <- "M4"
          } else {
            pred[i] <- "M6"
          }
        }
      }
    }
  }
  return(pred)
}

# ==============================================================================
# 2. main loop 
# ==============================================================================
run_one_simulation <- function(sim_id) {
  message(paste("\n=== 开始模拟 B =", sim_id, "==="))
  
  
  gen <- Generate_Data_MC(n_ind_fix)
  D <- gen$D
  Nutri <- gen$Nutri
  time_all <- gen$time
  true_cls <- gen$true_cls
  n_feat <- ncol(D)
  n_ind <- n_ind_fix
  n_time <- 3
  
  NutriDF <- as.data.frame(Nutri)
  design <- data.frame(id=rep(1:n_ind, each=n_time), time=rep(c(0,6,12), times=n_ind))
  design$time_fac <- factor(design$time)
  NutriC <- as.data.frame(scale(NutriDF, center=TRUE, scale=FALSE))
  base_df <- data.frame(id=factor(design$id), time=factor(design$time_fac))
  base_df <- cbind(base_df, NutriC)
  nutri_terms <- paste(colnames(NutriC), collapse=" + ")
  
  export_funcs <- c("fit_get_pvals", "safe_lmer", "calculate_effect_shares")
  
  # --- Step 1:  P-values  ---
  message("... 计算P值 ...")
  p_mat <- foreach(j = 1:n_feat, .combine = rbind, 
                   .export = export_funcs, 
                   .packages=c('lme4', 'RLRsim')) %dopar% {
    fit_get_pvals(D[,j], base_df, nutri_terms)
  }
  colnames(p_mat) <- c("p_interaction", "p_nutrition", "p_time", "p_RI")
  
  # LMM ANOVA Accuracy
  pred_lmm <- classify_by_anova(p_mat, alpha = 0.05)
  acc_lmm <- mean(pred_lmm == true_cls)
  message(paste("... LMM ANOVA Acc:", round(acc_lmm, 4)))
  
  # --- Step 2: Effect Shares  ---
  message("... 计算效应份额 ...")
  shares_mat <- foreach(j = 1:n_feat, .combine = rbind, 
                        .export = export_funcs,
                        .packages=c('lme4')) %dopar% {
    calculate_effect_shares(D[,j], design$id, design$time, Nutri)
  }
  colnames(shares_mat) <- c("interaction", "nutrition", "time", "individual", "residual")
  
  # --- Step 3 & 4: Bootstrapping Cutoffs  ---
  message("... Bootstrap: Interaction ...")
  inter_null_shares <- foreach(j = 1:n_feat, .combine = c, 
                               .export = export_funcs, .packages=c('lme4')) %dopar% {
    temp_df <- base_df; temp_df$y <- D[,j]
    fit <- safe_lmer(as.formula(paste0("y ~ time * (", nutri_terms, ") + (1|id)")), temp_df, TRUE)
    if(is.null(fit)) return(NA)
    X_main <- model.matrix(as.formula(paste0("y ~ time + ", nutri_terms)), data=temp_df)
    b <- fixef(fit); b_use <- b[colnames(X_main)]
    ran <- tryCatch(ranef(fit)$id[temp_df$id, 1], error=function(e) rep(0, nrow(temp_df)))
    y_new <- as.numeric(X_main %*% b_use) + ran + sample(residuals(fit), replace=TRUE)
    s <- calculate_effect_shares(y_new, temp_df$id, temp_df$time, Nutri)
    s[1]
  }
  cutoff_inter <- quantile(inter_null_shares, 0.95, na.rm=TRUE)
  
  message("... Bootstrap: Nutri/Time/Indiv ...")
  m2_null_results <- foreach(j = 1:n_feat, .combine = rbind, 
                             .export = export_funcs, .packages=c('lme4')) %dopar% {
    temp_df <- base_df; temp_df$y <- D[,j]
    fit_m2 <- safe_lmer(as.formula(paste0("y ~ time + ", nutri_terms, " + (1|id)")), temp_df, TRUE)
    if(is.null(fit_m2)) return(c(NA, NA, NA))
    res <- residuals(fit_m2); ran <- tryCatch(ranef(fit_m2)$id[temp_df$id,1], error=function(e) rep(0, nrow(temp_df))); fix <- fixef(fit_m2)
    
    X_noN <- model.matrix(~ time, data=temp_df); b_noN <- fix[colnames(X_noN)]
    y_noN <- as.numeric(X_noN %*% b_noN) + ran + sample(res, replace=TRUE)
    s_noN <- calculate_effect_shares(y_noN, temp_df$id, temp_df$time, Nutri)
    
    X_noT <- model.matrix(as.formula(paste0("~ ", nutri_terms)), data=temp_df); b_noT <- fix[colnames(X_noT)]
    y_noT <- as.numeric(X_noT %*% b_noT) + ran + sample(res, replace=TRUE)
    s_noT <- calculate_effect_shares(y_noT, temp_df$id, temp_df$time, Nutri)
    
    X_full <- model.matrix(fit_m2)
    y_noRI <- as.numeric(X_full %*% fix) + sample(res, replace=TRUE)
    s_noRI <- calculate_effect_shares(y_noRI, temp_df$id, temp_df$time, Nutri)
    c(s_noN[2], s_noT[3], s_noRI[4])
  }
  
  cutoff_nutri <- quantile(m2_null_results[,1], 0.95, na.rm=TRUE)
  cutoff_time  <- quantile(m2_null_results[,2], 0.95, na.rm=TRUE)
  cutoff_indiv <- quantile(m2_null_results[,3], 0.95, na.rm=TRUE)
  
  # --- Step 5: Contribution-based classification rules ---
  pred_contrib <- rep(NA, n_feat)
  S <- shares_mat
  c_I <- cutoff_inter; c_N <- cutoff_nutri; c_T <- cutoff_time; c_R <- cutoff_indiv
  alpha <- 0.05
  
  # 1. P-values to identify Non-sig (M7)
  
  is_nonsig <- (p_mat[,1] >= alpha) & (p_mat[,2] >= alpha) & 
               (p_mat[,3] >= alpha) & (p_mat[,4] >= alpha)
  pred_contrib[is_nonsig] <- "M7"
  

  mask <- is.na(pred_contrib)
  
  # 2.1 inter 
  pred_contrib[mask & (S[,1] > c_I)] <- "M1"
  mask <- is.na(pred_contrib)
  
  # 2.2 Random intercept
  idx_RI <- mask & (S[,4] > c_R)
  
  pred_contrib[idx_RI & (S[,2] > c_N) & (S[,3] > c_T)] <- "M2" # Nutri & Time
  pred_contrib[idx_RI & (S[,2] > c_N) & (S[,3] < c_T)] <- "M3" # Nutri Only
  pred_contrib[idx_RI & (S[,2] < c_N) & (S[,3] > c_T)] <- "M4" # Time Only
  pred_contrib[idx_RI & (S[,2] < c_N) & (S[,3] < c_T)] <- "M6" # RI Only
  
  mask <- is.na(pred_contrib)
  
  # 2.3 remaining Significant Features -> M5

  pred_contrib[mask] <- "M5"
  
  acc_contrib <- mean(pred_contrib == true_cls)
  message(paste("... Contribution-based Acc:", round(acc_contrib, 4)))
  

  create_dist_plot <- function(data_vec, cutoff, title, color) {
    df_p <- data.frame(val = na.omit(data_vec))
    ggplot(df_p, aes(x=val)) + 
      geom_density(fill=color, alpha=0.6) +
      geom_vline(xintercept=cutoff, color="red", linetype="dashed") +
      labs(title=paste0("Sim ", sim_id), 
           subtitle=paste0("Cutoff: ", round(cutoff, 3)), x=NULL, y=NULL) +
      theme_minimal(base_size = 8) + 
      theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(), plot.title = element_text(size=9))
  }
  
  return(list(
    sim_id = sim_id,
    acc_contrib = acc_contrib,
    acc_lmm = acc_lmm,
    cutoffs = c(inter=cutoff_inter, nutri=cutoff_nutri, time=cutoff_time, indiv=cutoff_indiv),
    plots = list(
      inter=create_dist_plot(inter_null_shares, cutoff_inter, "Interaction", "skyblue"),
      nutri=create_dist_plot(m2_null_results[,1], cutoff_nutri, "Nutrition", "orange"),
      time=create_dist_plot(m2_null_results[,2], cutoff_time, "Time", "lightgreen"),
      indiv=create_dist_plot(m2_null_results[,3], cutoff_indiv, "Individual", "mediumpurple")
    )
  ))
}

# ==============================================================================
# 3.  Monte Carlo simulation (B=12)
# ==============================================================================
results_list <- list()
message(paste("\n开始执行", B, "次 Monte Carlo 模拟..."))
start_time <- Sys.time()

for (b in 1:B) {
  results_list[[b]] <- run_one_simulation(b)
}

end_time <- Sys.time()
message(paste("\n模拟结束！总耗时:", round(difftime(end_time, start_time, units="mins"), 2), "分钟"))
stopCluster(cl)



acc_contrib_vec <- sapply(results_list, function(x) x$acc_contrib)
acc_lmm_vec <- sapply(results_list, function(x) x$acc_lmm)

# Table
cat("\n--- Accuracy per Simulation ---\n")
acc_table <- data.frame(
  Simulation = 1:B,
  LMM_ANOVA = round(acc_lmm_vec, 4),
  Contribution_Based = round(acc_contrib_vec, 4)
)
print(acc_table)

# Boxplot
acc_long <- pivot_longer(acc_table, cols = c("LMM_ANOVA", "Contribution_Based"), 
                         names_to = "Method", values_to = "Accuracy")

plot_acc_comparison <- ggplot(acc_long, aes(x=Method, y=Accuracy, fill=Method)) +
  geom_boxplot(alpha=0.6, outlier.shape = NA) +
  geom_jitter(width=0.1, size=2) +
  scale_fill_manual(values = c("LMM_ANOVA"="#E69F00", "Contribution_Based"="#56B4E9")) +
  labs(title = paste0("Accuracy Comparison (B=", B, ")"), 
       y="Accuracy", x="Classification Method") +
  theme_bw() + theme(legend.position = "none")

print(plot_acc_comparison)

# Distribution Plots
plots_inter <- lapply(results_list, function(x) x$plots$inter)
plots_nutri <- lapply(results_list, function(x) x$plots$nutri)
plots_time  <- lapply(results_list, function(x) x$plots$time)
plots_indiv <- lapply(results_list, function(x) x$plots$indiv)

print(wrap_plots(plots_inter, ncol = 4) + plot_annotation(title = "H0 Distribution: Interaction Share"))
print(wrap_plots(plots_nutri, ncol = 4) + plot_annotation(title = "H0 Distribution: Nutrition Share"))
print(wrap_plots(plots_time, ncol = 4) + plot_annotation(title = "H0 Distribution: Time Share"))
print(wrap_plots(plots_indiv, ncol = 4) + plot_annotation(title = "H0 Distribution: Individual Share"))

cat("\n--- Summary Statistics ---\n")
cat(sprintf("LMM ANOVA: Mean=%.4f, SD=%.4f\n", mean(acc_lmm_vec), sd(acc_lmm_vec)))
cat(sprintf("Contribution: Mean=%.4f, SD=%.4f\n", mean(acc_contrib_vec), sd(acc_contrib_vec)))
```


# B =20 Comparison of Classification Accuracy

```{r}

if (!require("pacman")) install.packages("pacman")
pacman::p_load(lme4, RLRsim, ggplot2, dplyr, tidyr, foreach, doParallel)


n_ind_levels <- c(50, 100, 150, 200) 
B <- 20                             



# --- 1.1 func of data generation with different sample sizes ---
Generate_Data_MC <- function(n_ind) {
  time_points <- c(0, 6, 12)
  n_time <- length(time_points)
  n_obs <- n_ind * n_time
  n_nutri <- 6
  np <- c(100, 100, 100, 100, 100, 100, 400)
  
  Nutri <- matrix(rnorm(n_obs * n_nutri), nrow = n_obs, ncol = n_nutri)
  colnames(Nutri) <- paste0("Nutri", 1:n_nutri)
  time_all <- rep(time_points, times = n_ind)
  
  D <- matrix(0, nrow = n_obs, ncol = sum(np))
  t_idx <- match(time_all, unique(time_points))
  ind_id <- rep(1:n_ind, each = n_time)
  
  curr <- 0
  # M1: Inter
  for(i in 1:np[1]) {
    curr <- curr + 1
    eff <- rowSums(Nutri * matrix(rnorm(n_time*n_nutri)[t_idx + (0:(n_nutri-1))*n_time], n_obs, n_nutri)) + 
           as.numeric(Nutri %*% rnorm(n_nutri)) + rnorm(n_time)[t_idx] + rnorm(n_ind)[ind_id]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M2: Nutri + Time + RI
  for(i in 1:np[2]) {
    curr <- curr + 1
    eff <- as.numeric(Nutri %*% rnorm(n_nutri)) + rnorm(n_time)[t_idx] + rnorm(n_ind)[ind_id]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M3: Nutri + RI
  for(i in 1:np[3]) {
    curr <- curr + 1
    eff <- as.numeric(Nutri %*% rnorm(n_nutri)) + rnorm(n_ind)[ind_id]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M4: Time + RI
  for(i in 1:np[4]) {
    curr <- curr + 1
    eff <- rnorm(n_time)[t_idx] + rnorm(n_ind)[ind_id]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M5: Nutri + Time (No RI)
  for(i in 1:np[5]) {
    curr <- curr + 1
    eff <- as.numeric(Nutri %*% rnorm(n_nutri)) + rnorm(n_time)[t_idx]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M6: RI Only
  for(i in 1:np[6]) {
    curr <- curr + 1
    eff <- rnorm(n_ind)[ind_id]
    D[, curr] <- eff + rnorm(n_obs)
  }
  # M7: Noise
  for(i in 1:np[7]) {
    curr <- curr + 1
    D[, curr] <- rnorm(n_obs)
  }
  
  true_cls <- rep(paste0("M", 1:7), times = np)
  return(list(D = D, Nutri = Nutri, time = time_all, true_cls = true_cls))
}

# --- 1.2 helper func ---
safe_lmer <- function(form, data, REML) {
  tryCatch(lmer(form, data = data, REML = REML, 
                control = lmerControl(check.conv.singular = "ignore", calc.derivs = FALSE)),
           error = function(e) NULL, warning = function(w) invokeRestart("muffleWarning"))
}

# P-values
fit_get_pvals <- function(yvec, base_df, nutri_terms) {
  df <- base_df; df$y <- as.numeric(yvec)
  f_add <- as.formula(paste0("y ~ time + ", nutri_terms, " + (1|id)"))
  f_full <- as.formula(paste0("y ~ time * (", nutri_terms, ") + (1|id)"))
  f_noN <- as.formula("y ~ time + (1|id)")
  f_noT <- as.formula(paste0("y ~ ", nutri_terms, " + (1|id)"))
  
  m_add <- safe_lmer(f_add, df, FALSE)
  m_full <- safe_lmer(f_full, df, FALSE)
  m_noN <- safe_lmer(f_noN, df, FALSE)
  m_noT <- safe_lmer(f_noT, df, FALSE)
  
  p_inter <- if(!is.null(m_add) && !is.null(m_full)) anova(m_add, m_full)$`Pr(>Chisq)`[2] else 1
  p_N <- if(!is.null(m_noN) && !is.null(m_add)) anova(m_noN, m_add)$`Pr(>Chisq)`[2] else 1
  p_T <- if(!is.null(m_noT) && !is.null(m_add)) anova(m_noT, m_add)$`Pr(>Chisq)`[2] else 1
  
  m_reml <- safe_lmer(update(f_add, .~.), df, TRUE)
  rlrt <- if(!is.null(m_reml)) tryCatch(RLRsim::exactRLRT(m_reml), error=function(e) NULL) else NULL
  p_RI <- if(!is.null(rlrt)) rlrt$p.value[1] else 1
  if(is.na(p_RI)) p_RI <- 1 
  
  return(c(p_inter, p_N, p_T, p_RI))
}

# effect shares
calculate_effect_shares <- function(y, id, time, Nutri_mat) {
  time <- factor(time); id <- factor(id)
  N <- scale(Nutri_mat, center = TRUE, scale = FALSE)
  df <- data.frame(y=y, id=id, time=time); df <- cbind(df, as.data.frame(N))
  
  nutri_cols <- colnames(N)
  inter_term <- paste0("(", paste(nutri_cols, collapse="+"), ")")
  form <- as.formula(paste0("y ~ ", inter_term, "*time + (1|id)"))
  
  fit <- safe_lmer(form, df, TRUE)
  if(is.null(fit)) return(rep(NA, 5))
  
  X <- model.matrix(fit); b <- fixef(fit); cn <- colnames(X)
  idx_nut <- grepl(paste0("^(", paste(nutri_cols, collapse="|"), ")$"), cn)
  idx_time <- grepl("^time", cn) & !grepl(":", cn)
  idx_int <- grepl(":", cn)
  
  calc_SS <- function(idx) {
    if(sum(idx)==0) return(0)
    eff <- as.numeric(X[, idx, drop=FALSE] %*% b[idx])
    sum((eff - mean(eff))^2)
  }
  SS_nut <- calc_SS(idx_nut)
  SS_time <- calc_SS(idx_time)
  SS_int <- calc_SS(idx_int)
  
  ran <- ranef(fit)$id[,1]
  SS_id <- sum(ran[df$id]^2)
  SS_eps <- sum(residuals(fit)^2)
  
  Ttot <- SS_nut + SS_time + SS_int + SS_id + SS_eps
  if(Ttot < 1e-9) return(rep(0, 5))
  
  res <- c(SS_int, SS_nut, SS_time, SS_id, SS_eps) / Ttot
  res[res < 0] <- 0
  if(sum(res) == 0) return(rep(0, 5))
  return(res / sum(res))
}

# --- 1.3 ANOVA classification rules ---
classify_by_anova <- function(p_mat, alpha = 0.05) {
  n <- nrow(p_mat)
  pred <- rep(NA, n)
  sig <- function(p) !is.na(p) & p < alpha
  
  for(i in 1:n) {
    p_I <- p_mat[i, 1]; p_N <- p_mat[i, 2]; p_T <- p_mat[i, 3]; p_RI <- p_mat[i, 4]
    
    if (!sig(p_I) && !sig(p_N) && !sig(p_T) && !sig(p_RI)) {
      pred[i] <- "M7"
    } else {
      if (sig(p_I)) {
        pred[i] <- "M1"
      } else {
        if (!sig(p_RI)) {
          pred[i] <- "M5"
        } else {
          if (sig(p_N) && sig(p_T)) {
            pred[i] <- "M2"
          } else if (sig(p_N) && !sig(p_T)) {
            pred[i] <- "M3"
          } else if (!sig(p_N) && sig(p_T)) {
            pred[i] <- "M4"
          } else {
            pred[i] <- "M6"
          }
        }
      }
    }
  }
  return(pred)
}

# ==============================================================================
# 2. single loop 
# ==============================================================================
run_simulation_for_n <- function(n_ind_current, sim_id) {
  
  
  gen <- Generate_Data_MC(n_ind_current)
  D <- gen$D
  Nutri <- gen$Nutri
  time_all <- gen$time
  true_cls <- gen$true_cls
  n_feat <- ncol(D)
  n_time <- 3
  
  NutriDF <- as.data.frame(Nutri)
  design <- data.frame(id=rep(1:n_ind_current, each=n_time), time=rep(c(0,6,12), times=n_ind_current))
  design$time_fac <- factor(design$time)
  NutriC <- as.data.frame(scale(NutriDF, center=TRUE, scale=FALSE))
  base_df <- data.frame(id=factor(design$id), time=factor(design$time_fac))
  base_df <- cbind(base_df, NutriC)
  nutri_terms <- paste(colnames(NutriC), collapse=" + ")
  
  export_funcs <- c("fit_get_pvals", "safe_lmer", "calculate_effect_shares")
  
  # --- 2.2 P-values---
  p_mat <- foreach(j = 1:n_feat, .combine = rbind, 
                   .export = export_funcs, 
                   .packages=c('lme4', 'RLRsim')) %dopar% {
    fit_get_pvals(D[,j], base_df, nutri_terms)
  }
  colnames(p_mat) <- c("p_interaction", "p_nutrition", "p_time", "p_RI")
  
  # -->  ANOVA -acc
  pred_lmm <- classify_by_anova(p_mat, alpha = 0.05)
  acc_lmm <- mean(pred_lmm == true_cls)
  
  # --- 2.3 effect shares ---
  shares_mat <- foreach(j = 1:n_feat, .combine = rbind, 
                        .export = export_funcs,
                        .packages=c('lme4')) %dopar% {
    calculate_effect_shares(D[,j], design$id, design$time, Nutri)
  }
  colnames(shares_mat) <- c("interaction", "nutrition", "time", "individual", "residual")
  
  # --- 2.4 Bootstrapping Cutoffs  ---

  # A. Interaction Cutoff
  inter_null_shares <- foreach(j = 1:n_feat, .combine = c, 
                               .export = export_funcs, .packages=c('lme4')) %dopar% {
    temp_df <- base_df; temp_df$y <- D[,j]
    fit <- safe_lmer(as.formula(paste0("y ~ time * (", nutri_terms, ") + (1|id)")), temp_df, TRUE)
    if(is.null(fit)) return(NA)
    X_main <- model.matrix(as.formula(paste0("y ~ time + ", nutri_terms)), data=temp_df)
    b <- fixef(fit); b_use <- b[colnames(X_main)]
    ran <- tryCatch(ranef(fit)$id[temp_df$id, 1], error=function(e) rep(0, nrow(temp_df)))
    y_new <- as.numeric(X_main %*% b_use) + ran + sample(residuals(fit), replace=TRUE)
    s <- calculate_effect_shares(y_new, temp_df$id, temp_df$time, Nutri)
    s[1]
  }
  cutoff_inter <- quantile(inter_null_shares, 0.95, na.rm=TRUE)
  
  # B. Nutri/Time/Indiv Cutoff
  m2_null_results <- foreach(j = 1:n_feat, .combine = rbind, 
                             .export = export_funcs, .packages=c('lme4')) %dopar% {
    temp_df <- base_df; temp_df$y <- D[,j]
    fit_m2 <- safe_lmer(as.formula(paste0("y ~ time + ", nutri_terms, " + (1|id)")), temp_df, TRUE)
    if(is.null(fit_m2)) return(c(NA, NA, NA))
    res <- residuals(fit_m2); ran <- tryCatch(ranef(fit_m2)$id[temp_df$id,1], error=function(e) rep(0, nrow(temp_df))); fix <- fixef(fit_m2)
    
    # H0 Nutri
    X_noN <- model.matrix(~ time, data=temp_df); b_noN <- fix[colnames(X_noN)]
    y_noN <- as.numeric(X_noN %*% b_noN) + ran + sample(res, replace=TRUE)
    s_noN <- calculate_effect_shares(y_noN, temp_df$id, temp_df$time, Nutri)
    
    # H0 Time
    X_noT <- model.matrix(as.formula(paste0("~ ", nutri_terms)), data=temp_df); b_noT <- fix[colnames(X_noT)]
    y_noT <- as.numeric(X_noT %*% b_noT) + ran + sample(res, replace=TRUE)
    s_noT <- calculate_effect_shares(y_noT, temp_df$id, temp_df$time, Nutri)
    
    # H0 RI
    X_full <- model.matrix(fit_m2)
    y_noRI <- as.numeric(X_full %*% fix) + sample(res, replace=TRUE)
    s_noRI <- calculate_effect_shares(y_noRI, temp_df$id, temp_df$time, Nutri)
    c(s_noN[2], s_noT[3], s_noRI[4])
  }
  
  cutoff_nutri <- quantile(m2_null_results[,1], 0.95, na.rm=TRUE)
  cutoff_time  <- quantile(m2_null_results[,2], 0.95, na.rm=TRUE)
  cutoff_indiv <- quantile(m2_null_results[,3], 0.95, na.rm=TRUE)
  
  # --- 2.5 Contribution-based Classification  ---
  pred_contrib <- rep(NA, n_feat)
  S <- shares_mat
  c_I <- cutoff_inter; c_N <- cutoff_nutri; c_T <- cutoff_time; c_R <- cutoff_indiv
  alpha <- 0.05
  
  # M7 non-sig 
  is_nonsig <- (p_mat[,1] >= alpha) & (p_mat[,2] >= alpha) & 
               (p_mat[,3] >= alpha) & (p_mat[,4] >= alpha)
  pred_contrib[is_nonsig] <- "M7"
  
  
  mask <- is.na(pred_contrib) 
  
  # inter 
  pred_contrib[mask & (S[,1] > c_I)] <- "M1"
  mask <- is.na(pred_contrib)
  
  
  idx_RI <- mask & (S[,4] > c_R)
  pred_contrib[idx_RI & (S[,2] > c_N) & (S[,3] > c_T)] <- "M2"
  pred_contrib[idx_RI & (S[,2] > c_N) & (S[,3] < c_T)] <- "M3"
  pred_contrib[idx_RI & (S[,2] < c_N) & (S[,3] > c_T)] <- "M4"
  pred_contrib[idx_RI & (S[,2] < c_N) & (S[,3] < c_T)] <- "M6"
  mask <- is.na(pred_contrib)
  
  # M5
  pred_contrib[mask] <- "M5"
  
  acc_contrib <- mean(pred_contrib == true_cls)
  
  return(c(n_ind = n_ind_current, sim = sim_id, acc_lmm = acc_lmm, acc_contrib = acc_contrib))
}

# ==============================================================================
# 3. main loop (High Stability Mode)
# ==============================================================================
final_results_df <- data.frame()


try(stopCluster(cl), silent = TRUE)
closeAllConnections()


start_time_total <- Sys.time()
num_cores <- parallel::detectCores() - 1

for (n_size in n_ind_levels) {
  message(paste0("\n##################################################"))
  message(paste0("### 开始处理样本量 n_ind = ", n_size, " ###"))
  message(paste0("##################################################"))
  

  
  for (b in 1:B) {
    message(paste0(">>> 样本量 ", n_size, " | 模拟轮次 ", b, "/", B, " ..."))
    
    
    cl_temp <- makeCluster(num_cores)
    registerDoParallel(cl_temp)
    
    
    tryCatch({
      res_vec <- run_simulation_for_n(n_size, b)
      
      final_results_df <- rbind(final_results_df, as.data.frame(t(res_vec)))
      
      message(paste0("    -> . ANOVA Acc: ", round(res_vec['acc_lmm'],4), 
                     " | Contrib Acc: ", round(res_vec['acc_contrib'],4)))
      
    }, error = function(e) {
      message(paste("    Error in simulation:", e$message))
    }, finally = {
      stopCluster(cl_temp)
    })
    
    gc() 
  }
}

end_time_total <- Sys.time()
message(paste("\n End of simulation! Total time:", round(difftime(end_time_total, start_time_total, units="mins"), 2), "min"))


```


```{r}

if(nrow(final_results_df) > 0) {
  colnames(final_results_df) <- c("Sample_Size", "Simulation", "LMM_ANOVA", "Contribution_Based")

  plot_data <- final_results_df %>%
    pivot_longer(cols = c("LMM_ANOVA", "Contribution_Based"), 
                 names_to = "Method", 
                 values_to = "Accuracy")
  
  
  plot_data$Sample_Size <- factor(plot_data$Sample_Size, levels = c(50, 100, 150, 200))
  

  
  p <- ggplot(plot_data, aes(x = Sample_Size, y = Accuracy, fill = Method)) +
    geom_boxplot(alpha = 0.6, outlier.shape = NA, position = position_dodge(width = 0.75), width = 0.6) +
    

    geom_point(aes(color = Method), 
               position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.75), 
               size = 1.5, alpha = 0.8) +
    
    labs(title = paste0("Accuracy Comparison across Sample Sizes"),
         subtitle = paste0("Each dot represents one independent simulation (Total B=", B, " per group)"),
         x = "Sample Size (n_ind)",
         y = "Classification Accuracy") +
    
    scale_fill_manual(values = c("LMM_ANOVA" = "#E69F00", "Contribution_Based" = "#56B4E9")) +
    scale_color_manual(values = c("LMM_ANOVA" = "#A37000", "Contribution_Based" = "#387CA3")) + # 点颜色深一点
    
    theme_bw() +
    theme(legend.position = "top",
          text = element_text(size = 12))
  
  print(p)
  
  summary_table <- plot_data %>%
    group_by(Sample_Size, Method) %>%
    summarise(
      Mean_Acc = mean(Accuracy),
      Min_Acc = min(Accuracy),
      Max_Acc = max(Accuracy),
      .groups = 'drop'
    )
  print(as.data.frame(summary_table))
  
} 
```

```{r}
output_filename_boxplot <- "Accuracy_Comparison_Boxplot.png"
ggsave(
  filename = output_filename_boxplot,
  plot = p, 
  width = 12,
  height = 8,
  units = "in",
  dpi = 300
)


if(exists("plots_inter") && length(plots_inter) > 0) {
  last_sim_idx <- length(plots_inter)
  
  combined_dist_plot <- (plots_inter[[last_sim_idx]] + plots_nutri[[last_sim_idx]]) / 
                        (plots_time[[last_sim_idx]] + plots_indiv[[last_sim_idx]]) +
    plot_annotation(
      title = "H0 Distributions of Effect Shares (Example from Last Simulation)",
      subtitle = "Red dashed lines indicate 95% quantile cutoffs",
      theme = theme(plot.title = element_text(hjust = 0.5, size = 16))
    )
  
  output_filename_dist <- "H0_Distribution_Plots_Example.png"
  ggsave(
    filename = output_filename_dist,
    plot = combined_dist_plot,
    width = 12,
    height = 10,
    units = "in",
    dpi = 300
  )
  message(paste("H0 distribution plot is saved as :", output_filename_dist))
  
} 

```

